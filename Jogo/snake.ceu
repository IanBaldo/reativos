#include "sdl.ceu"

native _printf();

#define BLOCK_WIDTH	20
#define BLOCK_HEIGHT	20
#define MAX_ROWS 	40
#define MAX_COLS	40
#define ROWS_COLS	1600
#define XY(x,y)		((x*MAX_COLS)+y)

input void SDL_REDRAW;
input void SDL_QUIT;
input _SDL_KeyboardEvent*    SDL_KEYDOWN;
event void new_food;

var int win_w;
var int win_h;

var char[ROWS_COLS] world;
var int[ROWS_COLS] snakeTrack_x;  // keeps track of the body position 
var int[ROWS_COLS] snakeTrack_y;
var int score = 0;

var _SDL_Window* win;
    finalize
        win = _SDL_CreateWindow("Snake",
                            500, 1300, 800, 800, _SDL_WINDOW_SHOWN);
    with
        _SDL_DestroyWindow(win);
    end

_SDL_GetWindowSize(win, &win_w, &win_h);

var _SDL_Renderer* ren;
    finalize
        ren = _SDL_CreateRenderer(win, -1, 0);
    with
        _SDL_DestroyRenderer(ren);
    end

// =====================         INITIALIZATION        ==============================

var _SDL_Rect bg;
    bg.w = win_w;
    bg.h = win_h;
    bg.x = 0;
    bg.y = 0;

var _SDL_Color bg_clr;
    bg_clr.r = 0x01;
    bg_clr.g = 0x01;
    bg_clr.b = 0x01;

var _SDL_Rect block;	// general use block
    	 block.w = BLOCK_WIDTH;
    	 block.h = BLOCK_HEIGHT;
    	 block.x = 0;
    	 block.y = 0;

var _SDL_Color wall_clr;	// white
	wall_clr.r = 0xFF;
	wall_clr.g = 0xFF;
	wall_clr.b = 0xFF;

var _SDL_Color snake_clr;	// dark green
	snake_clr.r = 0x00;
	snake_clr.g = 0xA0;
	snake_clr.b = 0x00;

var _SDL_Color food_clr;	// blue
	food_clr.r = 0x00;
	food_clr.g = 0x00;
	food_clr.b = 0xF0;

_SDL_SetRenderDrawColor(ren, bg_clr.r,bg_clr.g,bg_clr.b,0);
_SDL_RenderFillRect(ren, &bg);

loop i in MAX_ROWS-1 do		// initialize world
	var int pos = XY(0,i); 
	world[pos] = 'w';

	block.x = 0;
	block.y = i*BLOCK_HEIGHT;
	
	_SDL_SetRenderDrawColor(ren,wall_clr.r,wall_clr.g,wall_clr.b,0);
	_SDL_RenderFillRect(ren,&block);

	pos = XY((MAX_COLS-1),i);
	world[pos] = 'w';

	block.x = (MAX_COLS-1)*BLOCK_WIDTH;
	block.y = i*BLOCK_HEIGHT;

	_SDL_SetRenderDrawColor(ren,wall_clr.r,wall_clr.g,wall_clr.b,0);
	_SDL_RenderFillRect(ren,&block);
end

loop i in MAX_COLS-1 do
	var int pos = XY(i,0);
	world[pos] = 'w';

	block.x = i*BLOCK_WIDTH;
	block.y = 0;
	
	_SDL_SetRenderDrawColor(ren,wall_clr.r,wall_clr.g,wall_clr.b,0);
	_SDL_RenderFillRect(ren,&block);

	pos = XY(i,(MAX_ROWS-1));
	world[pos] = 'w';

	block.x = i*BLOCK_WIDTH;
	block.y = (MAX_ROWS-1)*BLOCK_HEIGHT;

	_SDL_SetRenderDrawColor(ren,wall_clr.r,wall_clr.g,wall_clr.b,0);
	_SDL_RenderFillRect(ren,&block);
end


// =====================          EXECUTION        ==============================

var int snakeHead_x = 2;
var int snakeHead_y = 2;
var int tailIndex = 0;
var int headIndex = 0;


par/or do			// GAME LOOP
    await SDL_QUIT;
with
    var char movement = 'R';
    await 10ms;
    emit new_food;
    loop do	
	var int eat = 0;
	par/or do //movement keyboard
		var _SDL_KeyboardEvent* key;
    		every key in SDL_KEYDOWN do
        		if key:keysym.sym == _SDLK_UP then
          		    movement = 'U';
       			 else/if key:keysym.sym == _SDLK_DOWN then
        		    movement = 'D';
       			 else/if key:keysym.sym == _SDLK_LEFT then
        		    movement = 'L';
       			 else/if key:keysym.sym == _SDLK_RIGHT then
        		    movement = 'R';
       			 end
   		 end
	with // timeout
		await 100ms;
	end
	// keep moving
	if (movement == 'U') then
		snakeHead_y = snakeHead_y - 1;
	else/if (movement == 'D') then
		snakeHead_y = snakeHead_y + 1;
	else/if (movement == 'L') then
		snakeHead_x = snakeHead_x - 1;
	else/if (movement == 'R') then
		snakeHead_x = snakeHead_x + 1;
	end
	
	var int pos = XY(snakeHead_x,snakeHead_y);
	if(world[pos] == 'w' or world[pos] == 's') then		
		block.x = snakeHead_x*BLOCK_WIDTH;
		block.y = snakeHead_y*BLOCK_HEIGHT;

		_SDL_SetRenderDrawColor(ren,0xFF,0x00,0x00,0);
		_SDL_RenderFillRect(ren,&block);
		
		_printf("SCORE = %d\n", score);		
		await FOREVER;
	else/if (world[pos] == 'f') then		
		emit new_food;
		eat = 1;
		score = score + 1;
	end

	world[pos] = 's';
	headIndex = headIndex + 1;
	if (headIndex == ROWS_COLS) then
		headIndex = 0;
	end
	snakeTrack_x[headIndex] = snakeHead_x;
	snakeTrack_y[headIndex] = snakeHead_y;	

	block.x = snakeHead_x*BLOCK_WIDTH;
	block.y = snakeHead_y*BLOCK_HEIGHT;

	_SDL_SetRenderDrawColor(ren,snake_clr.r,snake_clr.g,snake_clr.b,0);
	_SDL_RenderFillRect(ren,&block);

	block.x = snakeTrack_x[tailIndex]*BLOCK_WIDTH;
	block.y = snakeTrack_y[tailIndex]*BLOCK_HEIGHT;

	_SDL_SetRenderDrawColor(ren,0x01,0x01,0x01,0);
	_SDL_RenderFillRect(ren,&block);	

	if (eat==0) then
		var int pos_tail = XY(snakeTrack_x[tailIndex],snakeTrack_y[tailIndex]);		
		world[pos_tail] = '\0';
		tailIndex = tailIndex + 1;
		if (tailIndex == ROWS_COLS) then
			tailIndex = 0;
		end
	end
    end
with
	// GENERATE FOOD
	loop do
		await new_food;
		native _rand();
		loop do
			var int food_x = (_rand()%(MAX_COLS-2)) + 1;
			var int food_y = (_rand()%(MAX_ROWS-2)) + 1;

			var int food_pos = XY(food_x,food_y);
			if (world[food_pos] != 'w' or world[food_pos] != 's') then
				world[food_pos] = 'f';
				
				block.x = food_x*BLOCK_WIDTH;
				block.y = food_y*BLOCK_HEIGHT;
	
				_SDL_SetRenderDrawColor(ren,food_clr.r,food_clr.g,food_clr.b,0);
				_SDL_RenderFillRect(ren,&block);				
				break;
			end
		end
	end
with
    loop do
        await SDL_REDRAW;
        _SDL_RenderPresent(ren);
    end
end

escape 0;